-- Title: USB Mass Storage Device Sample + FAT32 (SD Card)
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q3
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Fat32 + USB MSD.
--              Acts as a mass storage device when USB is plugged in.
--              Can read/write via FAT32 lib when USB is not plugged in.
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
-- http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
-- http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
-- http://direction.scene-double.com/2008/07/08/usb-msd-bootloader-for-pic-microcontrollers.aspx
--
-- Notes:
--

include 18f67j50                      -- target PICmicro
--
-- This program uses the internal oscillator with PLL active.
pragma target clock 48_000_000      -- oscillator frequency
--
pragma target OSC      INTOSC_NOCLKOUT_PLL       -- internal oscillator
pragma target PLLDIV   P2                        -- 8 MHz -> 4 MHz
pragma target CPUDIV   P1                        -- Fosc divisor
pragma target WDT      CONTROL                   -- watchdog
pragma target XINST    DISABLED                  -- extended instruction set
pragma target DEBUG    DISABLED                  -- debugging
pragma target FCMEN    DISABLED                  -- clock monitoring
pragma target IESO     DISABLED                  -- int/ext osc. switch
--
-- The configuration bit settings above are only a selection, sufficient
-- for this program. Other programs may need more or different settings.
--
WDTCON_SWDTEN = OFF                 -- disable WDT
OSCCON_SCS = 0                      -- select primary oscillator
OSCTUNE_PLLEN = TRUE                -- use PLL
--
enable_digital_io()                 -- make all pins digital I/O
--
include delay                       -- library with delay procedures

const PRINT_MAX_VAR_SIZE = 6
include print

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available

-- setup SPI library
include spi_master_hw         -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
--
spi_init(SPI_MODE_11,SPI_RATE_FOSC_4) -- init spi, choose mode and speed
alias spi_master is spi_master_hw
alias spi_master_exchange is spi_master_hw_exchange

include format

-- enable usb debugging
const bit USB_DEBUG = FALSE
const bit USB_DEBUG_HIGH = FALSE
;const bit USB_HID_DEBUG = TRUE
;const bit USB_HID_DEBUG_HIGH = TRUE

-- setup debug lib
alias debug_data is serial_data
const bit DEBUG_MASTER_ENABLE = OFF    -- enables debugging
include debug
--
-- turn on and off debug levels.
debug_lvl_0 = ON  -- short debugging
debug_lvl_1 = OFF  -- display data in/out
debug_lvl_2 = OFF  -- display commands
debug_lvl_3 = OFF  -- short debug info
--
const byte debug_text0[] = "DEBUG STARTED"
debug_string(DEBUG_0,debug_text0)
debug_crlf(DEBUG_0)
--

-- setup the sd card pins
alias sd_chip_select is pin_SS
alias sd_chip_select_direction is pin_SS_direction
sd_chip_select = high
sd_chip_select_direction = output
--
-- setup the sd card library
alias sd_force_spi_mode is spi_master_hw_set_mode_11 -- always set spi mode to 1,1
const bit SD_READ_EXTRA_SPEED = TRUE -- extra speed
include sd_card              -- include the sd card ide hard disk library
sd_init()                    -- initialize startup settings
--
if sd_has_error == TRUE then
   const byte sd_has_error_MESSAGE[] = "ERROR - SD CARD FAILED"
   print_string(serial_data, sd_has_error_MESSAGE)
end if

-- setup MSD library
include usb_msd
usb_msd_init()
--
print_crlf(serial_data)
print_string(serial_data,"Your mass storage device size is ")
print_maxvar_dec(serial_data,byte*6(usb_msd_num_of_blocks)*512)
print_string(serial_data," bytes.")

-- setup fat32 --
-- include the required files
;include pic_data_eeprom
-- change these vaues to save memory
const bit FAT32_WRITE_LONG_FILE_NAMES = FALSE -- support writing of long file names
const word FAT32_FILES_MAX = 100            -- the max number of files allowed in a directory
const byte FAT32_FILE_NAME_SIZE = 80        -- choose max file_name size. if a file_name is longer the this, beginning chars will be cut. short file_names are 12 bytes.
const FAT32_DIR_FRAGMENTS_TO_ALLOW = 5     -- uses 6 bytes memory per fragment allowed (0 not allowed)
--                                          -- windows defrag does not defragment directories.
const FAT32_FILE_FRAGMENTS_TO_ALLOW = 5    -- uses 8 bytes memory per fragment allowed (0 not allowed)
--
-- experts may change the following values
;const byte FAT32_ENTRIES_MAX = 1           -- highest file entry address can be 256
const byte FAT32_ENTRIES_MAX = 2            -- highest file entry address can be 65535
--
-- choose a memory source for the file list
const bit FAT32_USE_INTERNAL_MEMORY = TRUE -- Use internal memory for file location list
IF FAT32_USE_INTERNAL_MEMORY == TRUE THEN
   -- Setup a large array for storing sector data, This is where file_name locations are stored
   const dword LARGE_ARRAY_2_SIZE = FAT32_FILES_MAX               -- choose number of array variables
   const dword LARGE_ARRAY_2_VARIABLE_SIZE = FAT32_ENTRIES_MAX    -- choose bytes size of variables
   include large_array_2                    -- include the array library
   ALIAS fat32_entry_location is large_array_2
elsif FAT32_USE_INTERNAL_MEMORY == FALSE THEN
   -- put your own code here if you wish to allow massive amounts of files per directory

   -- example usage of 23k256 for external memory

   -- alias the 23k256 device word array
   ;alias entry_location is sram_23k256_byte  -- highest file entry address can be 256
   alias fat32_entry_location is sram_23k256_word   -- highest file entry address can be 65535
END IF
--
include fat32   -- include fat32 library -- include fat32

-- CHOOSE FILE ATTRIBUTES TO FILTER OUT
fat32_filter_is_read_only  = FALSE
fat32_filter_is_hidden     = FALSE
fat32_filter_is_system     = FALSE
fat32_filter_is_volume_id  = FALSE
fat32_filter_is_directory  = FALSE
fat32_filter_is_archive    = FALSE

--------------------------------------------------------------------------------
-- main Program
--------------------------------------------------------------------------------

-- procedure for sending 80 "-----------------" via serial port
procedure separator() is
   serial_data = 13
   serial_data = 10
   const byte str3[] = "--------------------------------------------------------------------------------"
   print_string(serial_data, str3)
   print_crlf(serial_data)
end procedure

-- start of main program
separator()-- send "----"

fat32_init(1) -- initialize fat32, go to 1st primary partition's root dir "\"

--------------------------------------------------------------------------------
-- main loop
--------------------------------------------------------------------------------

-- define procedures and variables
procedure usb_disconnected_tasks()
procedure usb_connected_tasks()
var word char_count = 0
var word usb_check = 0
var byte usb_connected = TRUE

-- main loop to serve USB
forever loop
   -- poll the usb ISR function on a regular base, in order to
   -- serve the USB MSD requests
   usb_msd_tasks()

   -- Check if usb is still connected
   -- Another way would be to check the voltage on a USB+ pin.
   if USB_EVENT_OCCURRED == 1 then
      usb_check = 0
   elsif usb_check == 0xFFFF then
      -- USB is not connected
      usb_disconnected_tasks() -- perform your tasks
   else
      -- USB is connected
      usb_connected_tasks()
      usb_check = usb_check + 1
   end if
end loop

-- Do anything you want here while usb is disconnected.
-- Quit the procedure when USB_EVENT_OCCURRED = 1
procedure usb_disconnected_tasks() is
   if usb_connected == TRUE then
      print_crlf(serial_data)
      print_string(serial_data, "USB is disconnected." )
      usb_connected = FALSE
   end if

   ------------------------------------------------------------
   -- example fat32 user interaction,
   -- send file/dir number via serial port to go into it
   --
   -- if volume id selected, list the current dir (root dir)
   -- if directory selected go into it and list it
   -- if file selected go into file and read it
   ------------------------------------------------------------

   _fat32_read_dir_info() -- refresh the current dir
   fat32_print_directory(serial_data, FAT32_PRINT_ALL) -- see the procedure, sends dir listing via serial port
   separator() -- send "-----" and go to next example
   var byte data
   var dword step1
   var word step2
   var byte file_number2 = 0
   forever loop
      separator() -- send "-----" then loop and wait for user input

      -- this is not needed serial_sw.
      -- serial_data_available doesn't exist on serial sw.
      if defined(serial_data_available) then
         while !serial_data_available loop
            if USB_EVENT_OCCURRED == 1 then
               exit loop
            end if
         end loop
      end if
      
      if USB_EVENT_OCCURRED == 1 then
         exit loop
      end if

      file_number2 = serial_data

      -- choose a file for reading or dir for opening
      if fat32_cd(file_number2) then             -- if change directory is successful
         fat32_print_directory(serial_data, FAT32_PRINT_ALL) -- sends dir listing via serial port (with file numbers)
      elsif fat32_file_open(file_number2) then   -- if go into file is successful

         -- calculate number of sectors in file
         var dword sectors_available
         if (fat32_file_size) == (fat32_file_size / 512) * 512 then
            sectors_available = (fat32_file_size / 512)
         else
            sectors_available = (fat32_file_size / 512) + 1
         end if

         -- EXAMPLE 3 WRITE (fast and user friendly, suggested use)
         -- Read from any sector number in the file, in any order you wish.
   ;      for sectors_available using step1 loop
   ;
   ;         -- set the data to be written
   ;         for 512 using step2 loop
   ;            fat32_sector_buffer[step2] = "E"
   ;         end loop
   ;
   ;         -- write one sector to the disk
   ;         fat32_write_file_sector_number(step1)
   ;      end loop

         -- EXAMPLE 3 READ (fast and user friendly) from fat32 sample.
         -- Read from any sector number in the file, in any order you wish.
         for sectors_available using step1 loop
            -- read one sector from the disk
            fat32_read_file_sector_number(step1)
            -- send the sector via serial port
            for 512 using step2 loop
               serial_data = fat32_sector_buffer[step2]
            end loop
            
            if USB_EVENT_OCCURRED == 1 then
               exit loop
            end if
         end loop

         fat32_file_close()
      end if

      if USB_EVENT_OCCURRED == 1 then
         exit loop
      end if
   end loop


end procedure

-- Do anything you want here while usb is connected, but don't take long!
procedure usb_connected_tasks() is
   if usb_connected == FALSE then
      ;-- wait till MSD is configured
      usb_msd_wait_configured()
      print_crlf(serial_data)
      print_string(serial_data, "USB is connected." )
      usb_connected = TRUE
   end if

   -- poll the usb ISR function on a regular base, in order to
   -- serve the USB MSD requests
   usb_msd_tasks()
      
   -- let us know the PIC is actually doing something
   -- by sending char "." to serial port
   if char_count == 40000 then
      serial_data = "."
      _usec_delay(100)
      char_count = 0
   end if
   char_count = char_count + 1
end procedure





