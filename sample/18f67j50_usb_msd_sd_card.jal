-- Title: USB Mass Storage Device Sample (SD Card)
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q3
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Test program for USB MSD (Mass Storage Device) with SD card.
--
--              Here are my speed tests:
--              Read Speed (SD_READ_EXTRA_SPEED = TRUE)  - 205KB/s (usb only)
--              Read Speed (SD_READ_EXTRA_SPEED = FALSE) - 108KB/s
--              Write Speed                              - 110KB/s
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
-- http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
-- http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
-- http://direction.scene-double.com/2008/07/08/usb-msd-bootloader-for-pic-microcontrollers.aspx
--
-- Notes:
--

include 18f67j50                      -- target PICmicro
--
-- This program uses the internal oscillator with PLL active.
pragma target clock 48_000_000      -- oscillator frequency
--
pragma target OSC      INTOSC_NOCLKOUT_PLL       -- internal oscillator
pragma target PLLDIV   P2                        -- 8 MHz -> 4 MHz
pragma target CPUDIV   P1                        -- Fosc divisor
pragma target WDT      CONTROL                   -- watchdog
pragma target XINST    DISABLED                  -- extended instruction set
pragma target DEBUG    DISABLED                  -- debugging
pragma target FCMEN    DISABLED                  -- clock monitoring
pragma target IESO     DISABLED                  -- int/ext osc. switch
--
-- The configuration bit settings above are only a selection, sufficient
-- for this program. Other programs may need more or different settings.
--
WDTCON_SWDTEN = OFF                 -- disable WDT
OSCCON_SCS = 0                      -- select primary oscillator
OSCTUNE_PLLEN = TRUE                -- use PLL
--
enable_digital_io()                 -- make all pins digital I/O
--
include delay                       -- library with delay procedures

const PRINT_MAX_VAR_SIZE = 6
include print

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available

-- setup SPI library
include spi_master_hw         -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
--
spi_init(SPI_MODE_11,SPI_RATE_FOSC_4) -- init spi, choose mode and speed
alias spi_master is spi_master_hw
alias spi_master_exchange is spi_master_hw_exchange

include format

-- enable usb debugging
const bit USB_DEBUG = FALSE
const bit USB_DEBUG_HIGH = FALSE
;const bit USB_HID_DEBUG = TRUE
;const bit USB_HID_DEBUG_HIGH = TRUE

-- setup debug lib
alias debug_data is serial_data
const bit DEBUG_MASTER_ENABLE = OFF    -- enables debugging
include debug
--
-- turn on and off debug levels.
debug_lvl_0 = ON  -- short debugging
debug_lvl_1 = OFF  -- display data in/out
debug_lvl_2 = OFF  -- display commands
debug_lvl_3 = OFF  -- short debug info
--
const byte debug_text0[] = "DEBUG STARTED"
debug_string(DEBUG_0,debug_text0)
debug_crlf(DEBUG_0)
--

-- setup the sd card pins
alias sd_chip_select is pin_SS
alias sd_chip_select_direction is pin_SS_direction
sd_chip_select = high
sd_chip_select_direction = output
--
-- setup the sd card library
alias sd_force_spi_mode is spi_master_hw_set_mode_11 -- always set spi mode to 1,1
const bit SD_READ_EXTRA_SPEED = TRUE
include sd_card              -- include the sd card ide hard disk library
sd_init()                    -- initialize startup settings
--
if sd_has_error == TRUE then
   const byte SD_HAS_ERROR_MESSAGE[] = "ERROR - SD CARD FAILED"
   print_string(serial_data, SD_HAS_ERROR_MESSAGE)
end if

-- setup MSD library
include usb_msd
usb_msd_init()
print_crlf(serial_data)
print_string(serial_data,"Your mass storage device size is ")
print_maxvar_dec(serial_data,byte*6(usb_msd_num_of_blocks)*512)
print_string(serial_data," bytes.")

--------------------------------------------------------------------------------
-- main Program
--------------------------------------------------------------------------------

-- define procedures and variables
procedure usb_disconnected_tasks()
procedure usb_connected_tasks()
var word char_count = 0
var word usb_check = 0
var byte usb_connected = TRUE

-- main loop to serve USB
forever loop
   -- poll the usb ISR function on a regular base, in order to
   -- serve the USB MSD requests
   usb_msd_tasks()

   -- Check if usb is still connected
   -- Another way would be to check the voltage on a USB+ pin.
   if USB_EVENT_OCCURRED == 1 then
      usb_check = 0
   elsif usb_check == 0xFFFF then
      -- USB is not connected
      usb_disconnected_tasks() -- perform your tasks
   else
      -- USB is connected
      usb_connected_tasks()
      usb_check = usb_check + 1
   end if
end loop

-- Do anything you want here while usb is disconnected.
-- Quit the procedure when USB_EVENT_OCCURRED = 1
procedure usb_disconnected_tasks() is
   if usb_connected == TRUE then
      print_crlf(serial_data)
      print_string(serial_data, "USB is disconnected." )
      usb_connected = FALSE
   end if

   forever loop
      serial_data = "!"
      delay_1s(1)
      
      if USB_EVENT_OCCURRED == 1 then
         exit loop
      end if
   end loop
end procedure

-- Do anything you want here while usb is connected, but don't take long!
procedure usb_connected_tasks() is
   if usb_connected == FALSE then
      ;-- wait till MSD is configured
      usb_msd_wait_configured()
      print_crlf(serial_data)
      print_string(serial_data, "USB is connected." )
      usb_connected = TRUE
   end if

   -- poll the usb ISR function on a regular base, in order to
   -- serve the USB MSD requests
   usb_msd_tasks()
      
   -- let us know the PIC is actually doing something
   -- by sending char "." to serial port
   if char_count == 40000 then
      serial_data = "."
      _usec_delay(100)
      char_count = 0
   end if
   char_count = char_count + 1
end procedure






